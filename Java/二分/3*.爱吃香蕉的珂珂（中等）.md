# 题目 爱吃香蕉的珂珂

珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 ```piles[i]``` 根香蕉。警卫已经离开了，将在 h 小时后回来。

珂珂可以决定她吃香蕉的速度 k （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  

珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。

返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。

 

示例 1：

输入：```piles = [3,6,7,11]```, ```h = 8```

输出：4

示例 2：

输入：```piles = [30,11,23,4,20]```, ```h = 5```

输出：30

示例 3：

输入：```piles = [30,11,23,4,20]```, ```h = 6```

输出：23
 

提示：

* ```1 <= piles.length <= 104```
* ```piles.length <= h <= 109```
* ```1 <= piles[i] <= 109```

# 解答
```java
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int left = 0;
        int right = 0;
        for (int p : piles) {
            right = Math.max(right, p)+1;
        }
        while (left+1 < right) { // 开区间不为空
            int mid = left + (right - left) / 2;
            if (check(mid, piles, h)) {
                right = mid; // 循环不变量：恒为 true
            } else {
                left = mid; // 循环不变量：恒为 false
            }
        }
        return right; // 最小的 true
    }

    private boolean check(int mid, int[] piles, int h) {
        int sum = piles.length;
        for (int pile : piles) {
            sum += (pile - 1) / mid;
            if (sum > h) {
                return false;
            }
        }
        return true;
    }
}
```

# 总结

## 开区间与闭区间

闭区间指的是，条件不满足时，L和R的转移不包括mid，即：L = mid + 1，
R = mid - 1。一般来说，初始L,R也要满足闭区间，即L = 0，R = Len - 1。进入循环的条件应为 L <= R.当L和R相同时，本次循环区间还有一个数，当不满足条件时，下次循环开始前，L>R,不会进入循环，所以不会无限循环。

开区间指的是，条件不满足时，L和R的转移包括mid，即：L = mid，
R =mid。一般来说，初始L,R也要满足开区间，即L = -1，R = Len。进入循环的条件应为L < R-1.当L = R - 2时，看起来区间内有三个数，但由于是开区间，其中两边的数并不在区间范围内，所以目前区间也只有一个数，即mid。若不满足条件，下次循环前L = R-1，则循环不会进行，不会出现死循环。

实际上也可以一闭一开，即L或者R中的一个在转移时包括mid。这里设L为开，R为闭，则转移时，L = mid， R = mid - 1.初始条件应为L = -1，R = Len-1.进入循环的条件应为L<R.

## 循环不变性

循环不变量：关键不在于区间里的元素具有什么性质，而是区间外面的元素具有什么性质。一定要确保区间左外边满足同一个性质，右外边满足同一个性质。
也就是L-1和R +1，他们一定是所有L-1都过小，R+ 1都过大。

比如说，找出有序数组中第一个大于target的数。那么区间左边一定全都是小宇target的数，而右边一定是大于等于target的数。右边的数一定能满足结果，如果按照闭区间循环，只要返回R+1就是结果，实际上就是返回L，因为在最后一次循环中，L = R + 1。

这题也可以采用一开一闭来解，但是如果这题的mid是向下取整的话，必须是左闭右开才不会陷入死循环。当没有解的时候，若此时L = R - 1，而mid = L，此时mid < target,循环结束时，L仍然等于mid，则进入死循环。若是左闭右开，由于是向下取整mid = L，循环结束时，R = mid，即R = L，跳出循环。所以具体采用怎么开怎么闭还是要看题目，左开右闭一般用来求最大值。

## 查询条件
一般分为 >,<,=(太简单),>=,<=.5种情况

* 对于 > ,可以把他当作是>=target+1,在整数数组可以这样使用，把问题进行转换
* 对于 <，可以看作（>=target）-1，也就是>=类型题目中的返回结果的左边那个数
* 对于 <=,那就正好与>=反过来处理了


from 
* https://www.bilibili.com/video/BV1AP41137w7/?vd_source=f15cc092433f80abae3bb45b21608563
* https://blog.csdn.net/groovy2007/article/details/78309120


